# Symfony Shop REST API

Это пример REST-приложения на Symfony для расчёта цены продукта с налогами и купонами, а также проведения оплаты через разные платежные процессоры.

---

## Начало работы

Для установки выполните `make init`, что запустит Symfony-приложение на порту 8337, смонтировав текущую директорию в контейнер.
База данных будет создана, миграции будут запущены автоматически, тестовые данные будут в базе (фикстуры).

---

## Технологии

- PHP 8.3
- Symfony 6+
- Doctrine ORM (PostgreSQL)
- Docker
- OpenAPI / NelmioApiDocBundle
- PHPUnit
- Code Style Fixer, PHPStan, Psalm

---

## Эндпоинты

### 1. Расчёт цены

`POST /api/calculate-price`

**Тело запроса:**
`{ "product": 1, "taxNumber": "DE123456789", "couponCode": "P10" }`

**Ответ 200 OK:**
`{ "price": 107.10, "currency": "EUR" }`

**Пример ошибки (422):**
`{ "errors": ["Invalid tax number"] }`

---

### 2. Покупка

`POST /api/purchase`

**Тело запроса:**
`{ "product": 1, "taxNumber": "DE123456789", "couponCode": "P10", "paymentProcessor": "paypal" }`

**Ответ 200 OK:**
`{ "orderId": 101, "total": 107.10, "currency": "EUR" }`

**Пример ошибки (422):**
- Отсутствует `paymentProcessor`: `{ "errors": { "paymentProcessor": "This value should not be blank." } }`

---

## DTO и валидация

- `CalculatePriceRequest`
    - `product` (integer, обязательное, >0)
    - `taxNumber` (строка, обязательное, валидируется кастомным `TaxNumber`)
    - `couponCode` (строка, опционально)

- `PurchaseRequest` — дополнительно:
    - `paymentProcessor` (строка, обязательное, один из `paypal` или `stripe`)

- Кастомный валидатор `TaxNumberValidator` проверяет формат налогового номера по стране (DE/IT/FR/GR) через `TaxRate::fromTaxNumber()`.
- Все ошибки валидации собираются в массив и возвращаются с HTTP 422.

---

## Сущности

- `Product` — товары с ценой в `Money` (cents + currency)
- `Coupon` — скидки двух типов:
    - Процент (`percent`) — например, 10%
    - Фиксированная сумма (`fixed`) — в центах
- `Order` — заказ с оригинальной ценой, суммой с налогами и купоном, статусом платежа.

---

## Сервисы

- `PriceCalculatorService` — рассчитывает итоговую сумму с налогами и купонами.
- `PaymentService` — обрабатывает оплату через `PaypalPaymentProcessor` или `StripePaymentProcessor`.
- `ShopService` — главный сервис:
    1. Получает продукт и купон.
    2. Вычисляет итоговую цену.
    3. Создаёт заказ со статусом PENDING.
    4. Проводит оплату.
    5. Обновляет статус заказа (PAID или FAILED).

---

## Логика ошибок

1. Валидация DTO (`RequestDtoResolver`) → `UnprocessableEntityHttpException` при нарушениях.
2. `ApiExceptionSubscriber` перехватывает исключения для API-запросов (`Accept: application/json`) и возвращает JSON-массив ошибок.
3. Примеры ошибок:
    - Некорректный `taxNumber` → `["Invalid tax number"]`
    - Неположительный или отсутствующий `product` → `{ "product": "This value should be positive." }`
    - Неизвестный купон → `["Invalid or inactive coupon"`]
    - Неизвестный платежный процессор → `["The value you selected is not a valid choice."]`

---

## Примеры запросов

- `requests-success.http` — успешные кейсы расчёта и покупки
- `requests-error.http` — кейсы с ошибками и валидацией

---

## Pre-commit Hooks

Установить хуки можно командой `composer install-hooks` внутри контейнера.
Удалить через `composer remove-hooks`.

Проверки идут через:
- Code Style Fixer
- PHPStan
- Psalm
- PHPUnit

---

## Добавление новой платежной системы

Чтобы подключить новый платежный сервис:
1. Создайте класс-адаптер, реализующий `PaymentProcessorInterface`.
2. Пометьте класс атрибутом `#[PaymentProcessor('alias')]`, где alias — уникальный идентификатор процессора.
3. Проверьте доступность нового процессора
`php bin/console debug:container --tag=app.payment_processor`

---

## Добавление нового налогового номера

Чтобы подключить новой налоговый номер:
1. Создайте класс, реализующий `TaxRateInterface`.
2. Пометьте класс атрибутом `#[CountryTaxRate('alias')]`, где alias — уникальный идентификатор налогового номера.
3. Проверьте доступность нового налогового номера
   `php bin/console debug:container --tag=app.country_tax_rate`

---

## Технические решения

1. Чтобы избежать громоздкого контроллера - валидация входных данных вынесена в `RequestDtoResolver`.
В контроллер приходит уже проверенный DTO, реализующий интерфейс `RequestDtoInterface`.
2. Для поддержания чистоты кода и единства обработки - обработка всех исключений вынесена в `ApiExceptionSubscriber`.
3. Все расчёты производятся в центах, чтобы избежать потерь при математических вычислениях.
Создан класс Money для удобства хранения информации о валюте.
4. В рамках тестового задания не стал добавлять кеширование, работу с очередями и устойчивость от падения внешнего (платёжного) сервиса.
Это бы усложнило систему.
5. Для заказов был добавлен статус платежа, чтобы избежать проблемы, когда заказ был создан, а оплата не прошла (либо же наоборот заказ не создался после оплаты).
Благодаря логированию и статусу - такой случай можно выявить и корректно обработать.
6. Возвращаемые на фронтенд ошибки приведены к единому формату. Все ошибки возвращаются со статусом 422 по умолчанию.
`{ "errors": { "paymentProcessor": "This value should not be blank." }`
7. К эндпоинтам было добавлено `/api` - для более удобной работы со swagger и возможным версионированием
8. Для функциональных тестов база 1 раз пересоздаётся с целью минимизировать воздействие тестов друг на друга.
База данных не пересоздаётся после каждого теста, в этом нет необходимости и это увеличивает скорость прохождения тестов.